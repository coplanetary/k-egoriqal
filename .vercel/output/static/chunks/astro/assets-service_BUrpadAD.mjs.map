{"version":3,"file":"assets-service_BUrpadAD.mjs","sources":["../../../../../node_modules/astro/node_modules/@astrojs/internal-helpers/dist/path.js","../../../../../node_modules/astro/dist/assets/consts.js","../../../../../node_modules/astro/dist/assets/utils/imageKind.js","../../../../../node_modules/astro/dist/assets/services/service.js"],"sourcesContent":["function appendExtension(path, extension) {\n  return path + \".\" + extension;\n}\nfunction appendForwardSlash(path) {\n  return path.endsWith(\"/\") ? path : path + \"/\";\n}\nfunction prependForwardSlash(path) {\n  return path[0] === \"/\" ? path : \"/\" + path;\n}\nfunction collapseDuplicateSlashes(path) {\n  return path.replace(/(?<!:)\\/{2,}/g, \"/\");\n}\nfunction removeTrailingForwardSlash(path) {\n  return path.endsWith(\"/\") ? path.slice(0, path.length - 1) : path;\n}\nfunction removeLeadingForwardSlash(path) {\n  return path.startsWith(\"/\") ? path.substring(1) : path;\n}\nfunction removeLeadingForwardSlashWindows(path) {\n  return path.startsWith(\"/\") && path[2] === \":\" ? path.substring(1) : path;\n}\nfunction trimSlashes(path) {\n  return path.replace(/^\\/|\\/$/g, \"\");\n}\nfunction startsWithForwardSlash(path) {\n  return path[0] === \"/\";\n}\nfunction startsWithDotDotSlash(path) {\n  const c1 = path[0];\n  const c2 = path[1];\n  const c3 = path[2];\n  return c1 === \".\" && c2 === \".\" && c3 === \"/\";\n}\nfunction startsWithDotSlash(path) {\n  const c1 = path[0];\n  const c2 = path[1];\n  return c1 === \".\" && c2 === \"/\";\n}\nfunction isRelativePath(path) {\n  return startsWithDotDotSlash(path) || startsWithDotSlash(path);\n}\nfunction isString(path) {\n  return typeof path === \"string\" || path instanceof String;\n}\nfunction joinPaths(...paths) {\n  return paths.filter(isString).map((path, i) => {\n    if (i === 0) {\n      return removeTrailingForwardSlash(path);\n    } else if (i === paths.length - 1) {\n      return removeLeadingForwardSlash(path);\n    } else {\n      return trimSlashes(path);\n    }\n  }).join(\"/\");\n}\nfunction removeFileExtension(path) {\n  let idx = path.lastIndexOf(\".\");\n  return idx === -1 ? path : path.slice(0, idx);\n}\nfunction removeQueryString(path) {\n  const index = path.lastIndexOf(\"?\");\n  return index > 0 ? path.substring(0, index) : path;\n}\nfunction isRemotePath(src) {\n  return /^(?:http|ftp|https|ws):?\\/\\//.test(src) || src.startsWith(\"data:\");\n}\nfunction slash(path) {\n  return path.replace(/\\\\/g, \"/\");\n}\nfunction fileExtension(path) {\n  const ext = path.split(\".\").pop();\n  return ext !== path ? `.${ext}` : \"\";\n}\nfunction removeBase(path, base) {\n  if (path.startsWith(base)) {\n    return path.slice(removeTrailingForwardSlash(base).length);\n  }\n  return path;\n}\nexport {\n  appendExtension,\n  appendForwardSlash,\n  collapseDuplicateSlashes,\n  fileExtension,\n  isRelativePath,\n  isRemotePath,\n  joinPaths,\n  prependForwardSlash,\n  removeBase,\n  removeFileExtension,\n  removeLeadingForwardSlash,\n  removeLeadingForwardSlashWindows,\n  removeQueryString,\n  removeTrailingForwardSlash,\n  slash,\n  startsWithDotDotSlash,\n  startsWithDotSlash,\n  startsWithForwardSlash,\n  trimSlashes\n};\n","const VIRTUAL_MODULE_ID = \"astro:assets\";\nconst VIRTUAL_SERVICE_ID = \"virtual:image-service\";\nconst VALID_INPUT_FORMATS = [\n  \"jpeg\",\n  \"jpg\",\n  \"png\",\n  \"tiff\",\n  \"webp\",\n  \"gif\",\n  \"svg\",\n  \"avif\"\n];\nconst VALID_SUPPORTED_FORMATS = [\n  \"jpeg\",\n  \"jpg\",\n  \"png\",\n  \"tiff\",\n  \"webp\",\n  \"gif\",\n  \"svg\",\n  \"avif\"\n];\nconst DEFAULT_OUTPUT_FORMAT = \"webp\";\nconst VALID_OUTPUT_FORMATS = [\"avif\", \"png\", \"webp\", \"jpeg\", \"jpg\", \"svg\"];\nconst DEFAULT_HASH_PROPS = [\"src\", \"width\", \"height\", \"format\", \"quality\"];\nexport {\n  DEFAULT_HASH_PROPS,\n  DEFAULT_OUTPUT_FORMAT,\n  VALID_INPUT_FORMATS,\n  VALID_OUTPUT_FORMATS,\n  VALID_SUPPORTED_FORMATS,\n  VIRTUAL_MODULE_ID,\n  VIRTUAL_SERVICE_ID\n};\n","function isESMImportedImage(src) {\n  return typeof src === \"object\";\n}\nfunction isRemoteImage(src) {\n  return typeof src === \"string\";\n}\nasync function resolveSrc(src) {\n  return typeof src === \"object\" && \"then\" in src ? (await src).default ?? await src : src;\n}\nexport {\n  isESMImportedImage,\n  isRemoteImage,\n  resolveSrc\n};\n","import { AstroError, AstroErrorData } from \"../../core/errors/index.js\";\nimport { isRemotePath, joinPaths } from \"../../core/path.js\";\nimport { DEFAULT_HASH_PROPS, DEFAULT_OUTPUT_FORMAT, VALID_SUPPORTED_FORMATS } from \"../consts.js\";\nimport { isESMImportedImage } from \"../utils/imageKind.js\";\nimport { isRemoteAllowed } from \"../utils/remotePattern.js\";\nfunction isLocalService(service) {\n  if (!service) {\n    return false;\n  }\n  return \"transform\" in service;\n}\nfunction parseQuality(quality) {\n  let result = parseInt(quality);\n  if (Number.isNaN(result)) {\n    return quality;\n  }\n  return result;\n}\nconst baseService = {\n  propertiesToHash: DEFAULT_HASH_PROPS,\n  validateOptions(options) {\n    if (!options.src || typeof options.src !== \"string\" && typeof options.src !== \"object\") {\n      throw new AstroError({\n        ...AstroErrorData.ExpectedImage,\n        message: AstroErrorData.ExpectedImage.message(\n          JSON.stringify(options.src),\n          typeof options.src,\n          JSON.stringify(options, (_, v) => v === void 0 ? null : v)\n        )\n      });\n    }\n    if (!isESMImportedImage(options.src)) {\n      if (options.src.startsWith(\"/@fs/\") || !isRemotePath(options.src) && !options.src.startsWith(\"/\")) {\n        throw new AstroError({\n          ...AstroErrorData.LocalImageUsedWrongly,\n          message: AstroErrorData.LocalImageUsedWrongly.message(options.src)\n        });\n      }\n      let missingDimension;\n      if (!options.width && !options.height) {\n        missingDimension = \"both\";\n      } else if (!options.width && options.height) {\n        missingDimension = \"width\";\n      } else if (options.width && !options.height) {\n        missingDimension = \"height\";\n      }\n      if (missingDimension) {\n        throw new AstroError({\n          ...AstroErrorData.MissingImageDimension,\n          message: AstroErrorData.MissingImageDimension.message(missingDimension, options.src)\n        });\n      }\n    } else {\n      if (!VALID_SUPPORTED_FORMATS.includes(options.src.format)) {\n        throw new AstroError({\n          ...AstroErrorData.UnsupportedImageFormat,\n          message: AstroErrorData.UnsupportedImageFormat.message(\n            options.src.format,\n            options.src.src,\n            VALID_SUPPORTED_FORMATS\n          )\n        });\n      }\n      if (options.widths && options.densities) {\n        throw new AstroError(AstroErrorData.IncompatibleDescriptorOptions);\n      }\n      if (options.src.format === \"svg\") {\n        options.format = \"svg\";\n      }\n      if (options.src.format === \"svg\" && options.format !== \"svg\" || options.src.format !== \"svg\" && options.format === \"svg\") {\n        throw new AstroError(AstroErrorData.UnsupportedImageConversion);\n      }\n    }\n    if (!options.format) {\n      options.format = DEFAULT_OUTPUT_FORMAT;\n    }\n    if (options.width)\n      options.width = Math.round(options.width);\n    if (options.height)\n      options.height = Math.round(options.height);\n    return options;\n  },\n  getHTMLAttributes(options) {\n    const { targetWidth, targetHeight } = getTargetDimensions(options);\n    const { src, width, height, format, quality, densities, widths, formats, ...attributes } = options;\n    return {\n      ...attributes,\n      width: targetWidth,\n      height: targetHeight,\n      loading: attributes.loading ?? \"lazy\",\n      decoding: attributes.decoding ?? \"async\"\n    };\n  },\n  getSrcSet(options) {\n    const srcSet = [];\n    const { targetWidth } = getTargetDimensions(options);\n    const { widths, densities } = options;\n    const targetFormat = options.format ?? DEFAULT_OUTPUT_FORMAT;\n    let imageWidth = options.width;\n    let maxWidth = Infinity;\n    if (isESMImportedImage(options.src)) {\n      imageWidth = options.src.width;\n      maxWidth = imageWidth;\n    }\n    const {\n      width: transformWidth,\n      height: transformHeight,\n      ...transformWithoutDimensions\n    } = options;\n    const allWidths = [];\n    if (densities) {\n      const densityValues = densities.map((density) => {\n        if (typeof density === \"number\") {\n          return density;\n        } else {\n          return parseFloat(density);\n        }\n      });\n      const densityWidths = densityValues.sort().map((density) => Math.round(targetWidth * density));\n      allWidths.push(\n        ...densityWidths.map((width, index) => ({\n          maxTargetWidth: Math.min(width, maxWidth),\n          descriptor: `${densityValues[index]}x`\n        }))\n      );\n    } else if (widths) {\n      allWidths.push(\n        ...widths.map((width) => ({\n          maxTargetWidth: Math.min(width, maxWidth),\n          descriptor: `${width}w`\n        }))\n      );\n    }\n    for (const { maxTargetWidth, descriptor } of allWidths) {\n      const srcSetTransform = { ...transformWithoutDimensions };\n      if (maxTargetWidth !== imageWidth) {\n        srcSetTransform.width = maxTargetWidth;\n      } else {\n        if (options.width && options.height) {\n          srcSetTransform.width = options.width;\n          srcSetTransform.height = options.height;\n        }\n      }\n      srcSet.push({\n        transform: srcSetTransform,\n        descriptor,\n        attributes: {\n          type: `image/${targetFormat}`\n        }\n      });\n    }\n    return srcSet;\n  },\n  getURL(options, imageConfig) {\n    const searchParams = new URLSearchParams();\n    if (isESMImportedImage(options.src)) {\n      searchParams.append(\"href\", options.src.src);\n    } else if (isRemoteAllowed(options.src, imageConfig)) {\n      searchParams.append(\"href\", options.src);\n    } else {\n      return options.src;\n    }\n    const params = {\n      w: \"width\",\n      h: \"height\",\n      q: \"quality\",\n      f: \"format\"\n    };\n    Object.entries(params).forEach(([param, key]) => {\n      options[key] && searchParams.append(param, options[key].toString());\n    });\n    const imageEndpoint = joinPaths(import.meta.env.BASE_URL, \"/_image\");\n    return `${imageEndpoint}?${searchParams}`;\n  },\n  parseURL(url) {\n    const params = url.searchParams;\n    if (!params.has(\"href\")) {\n      return void 0;\n    }\n    const transform = {\n      src: params.get(\"href\"),\n      width: params.has(\"w\") ? parseInt(params.get(\"w\")) : void 0,\n      height: params.has(\"h\") ? parseInt(params.get(\"h\")) : void 0,\n      format: params.get(\"f\"),\n      quality: params.get(\"q\")\n    };\n    return transform;\n  }\n};\nfunction getTargetDimensions(options) {\n  let targetWidth = options.width;\n  let targetHeight = options.height;\n  if (isESMImportedImage(options.src)) {\n    const aspectRatio = options.src.width / options.src.height;\n    if (targetHeight && !targetWidth) {\n      targetWidth = Math.round(targetHeight * aspectRatio);\n    } else if (targetWidth && !targetHeight) {\n      targetHeight = Math.round(targetWidth / aspectRatio);\n    } else if (!targetWidth && !targetHeight) {\n      targetWidth = options.src.width;\n      targetHeight = options.src.height;\n    }\n  }\n  return {\n    targetWidth,\n    targetHeight\n  };\n}\nexport {\n  baseService,\n  isLocalService,\n  parseQuality\n};\n"],"names":[],"mappings":"qVAMA,QAAS,CAAA,mBAAmB,CAAC,IAAI,CAAE,CAAA,CAAA;AACnC,CAAA,CAAE,MAAO,CAAA,IAAI,CAAC,CAAC,CAAC,CAAA,CAAA,CAAA,CAAA,CAAK,CAAG,CAAA,CAAA,CAAA,CAAA,CAAG,IAAI,CAAA,CAAA,CAAG,CAAG,CAAA,CAAA,CAAA,CAAA,CAAG,IAAI,CAAC;AAC7C,CAAA;;ACgBK,KAAC,CAAA,kBAAkB,CAAG,CAAA,CAAA,CAAC,CAAK,GAAA,CAAA,CAAA,CAAE,CAAO,KAAA,CAAA,CAAA,CAAE,CAAQ,MAAA,CAAA,CAAA,CAAE,CAAQ,MAAA,CAAA,CAAA,CAAE,CAAS,OAAA,CAAA,CAAA,CAAA;;ACxBzE,QAAS,CAAA,kBAAkB,CAAC,GAAG,CAAE,CAAA,CAAA;AACjC,CAAA,CAAE,MAAO,CAAA,MAAA,CAAO,GAAG,CAAA,CAAA,CAAA,CAAA,CAAK,QAAQ,CAAC;AACjC,CAAC;AACD,QAAS,CAAA,aAAa,CAAC,GAAG,CAAE,CAAA,CAAA;AAC5B,CAAA,CAAE,MAAO,CAAA,MAAA,CAAO,GAAG,CAAA,CAAA,CAAA,CAAA,CAAK,QAAQ,CAAC;AACjC,CAAC;AACD,KAAe,CAAA,QAAA,CAAA,UAAU,CAAC,GAAG,CAAE,CAAA,CAAA;AAC/B,CAAE,CAAA,MAAA,CAAO,OAAO,GAAG,CAAA,CAAA,CAAA,CAAA,CAAK,QAAQ,CAAI,CAAA,CAAA,CAAA,CAAA,IAAA,CAAM,IAAI,GAAG,CAAA,CAAA,CAAG,CAAC,KAAM,CAAA,GAAG,EAAE,OAAO,CAAA,CAAA,CAAA,CAAI,MAAM,GAAG,CAAA,CAAA,CAAG,GAAG,CAAC;AAC3F,CAAA;;ACHA,QAAS,CAAA,eAAe,OAAS,CAAA,CAAA,CAAA;AAC/B,CAAA,CAAA,EAAA,CAAA,CAAI,CAAC,OAAS,CAAA,CAAA,CAAA;AACL,CAAA,CAAA,CAAA,CAAA,MAAA,CAAA,KAAA,CAAA;AAAA,CACT,CAAA,CAAA;AACA,CAAA,CAAA,MAAO,CAAA,CAAA,SAAA,CAAe,CAAA,EAAA,CAAA,OAAA,CAAA;AACxB,CAAA;;","x_google_ignoreList":[0,1,2,3]}